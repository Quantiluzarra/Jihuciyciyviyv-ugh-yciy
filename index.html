<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Arena Online</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(45deg, #1a1a1a, #2d2d2d);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      padding: 30px;
      background: rgba(0,0,0,0.7);
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      transition: all 0.3s;
    }

    #uiPanel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      padding: 20px;
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .betButton, .startButton {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      cursor: pointer;
      font-size: 16px;
    }

    .redButton {
      background: linear-gradient(120deg, #e62e2e, #b31212);
      color: #fff;
    }

    .blueButton {
      background: linear-gradient(120deg, #007bff, #0056b3);
      color: #fff;
    }

    .startButton {
      background: linear-gradient(120deg, #28a745, #196d36);
      color: #fff;
    }

    .betButton:hover, .startButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }

    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 800px;
      border-radius: 10px;
      overflow: hidden;
      margin: 20px 0;
      background: #1a1a1a;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #logPanel {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      padding: 15px;
      color: #e8e8e8;
      font-size: 14px;
      line-height: 1.5;
      margin-top: 15px;
    }

    .hp-bar {
      position: absolute;
      height: 10px;
      border-radius: 5px;
      background: #222;
    }

    .hp-fill {
      height: 100%;
      transition: width 0.3s;
    }

    .attack-effect {
      position: absolute;
      border: 2px solid #fff;
      border-radius: 50%;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(0.5); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 0.4; }
      100% { transform: scale(0.5); opacity: 0; }
    }

    .emoji {
      position: absolute;
      font-size: 24px;
      color: #fff;
      animation: float 2s linear infinite;
    }

    @keyframes float {
      0% { transform: translateY(0); }
      100% { transform: translateY(-30px); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>AI Arena Online</h1>
    <div id="uiPanel">
      <div class="info">
        <div>–ë–∞–ª–∞–Ω—Å: <span id="balance">1000</span> C</div>
        <div>–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã: 
          <span id="redOdds">1.50</span> / 
          <span id="blueOdds">1.50</span>
        </div>
      </div>
      <div class="betting">
        <input id="betAmount" type="number" value="100" min="1" style="padding:8px; margin:5px;">
        <button class="betButton redButton" onclick="betOn('red')">–ö—Ä–∞—Å–Ω—ã–π</button>
        <button class="betButton blueButton" onclick="betOn('blue')">–°–∏–Ω–∏–π</button>
      </div>
      <button class="startButton" onclick="startGame()">–ù–∞—á–∞—Ç—å –±–æ–π</button>
    </div>
    
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div id="logPanel"></div>
  </div>

<script>
const CELL_SIZE = 32;
const GRID_SIZE = 20;
const MAX_HP = 100;
const MOVE_SPEED = 0.1;

let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let logPanel = document.getElementById('logPanel');
let gameRunning = false;
let redAI, blueAI;
let playerBalance = 1000;
let betTeam = null;
let betValue = 0;
let redOdds = 1.5;
let blueOdds = 1.5;
let lastAnimationFrame = 0;
let attackEffects = [];
let emojis = [];
let grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(0));

// –ò–ò –ø–∞–º—è—Ç—å
const redMemory = JSON.parse(localStorage.getItem('redMemory')) || {};
const blueMemory = JSON.parse(localStorage.getItem('blueMemory')) || {};

class AI {
  constructor(type, x, y, baseX, baseY) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.baseX = baseX;
    this.baseY = baseY;
    this.hp = MAX_HP;
    this.memory = type === 1 ? redMemory : blueMemory;
    this.color = type === 1 ? '#e62e2e' : '#007bff';
    this.target = {x, y};
    this.lastAction = 0;
  }

  decideMove(opponent) {
    const now = performance.now();
    if (now - this.lastAction < 800) return;
    this.lastAction = now;
    
    const directions = [
      {dx: 0, dy: -1},
      {dx: 0, dy: 1},
      {dx: -1, dy: 0},
      {dx: 1, dy: 0}
    ];

    let bestDir = directions[0];
    let maxScore = -Infinity;

    directions.forEach(dir => {
      const nx = this.x + dir.dx;
      const ny = this.y + dir.dy;
      const key = `${nx},${ny},${opponent.x},${opponent.y},${this.hp}`;
      const score = this.memory[key] || 0;
      if (score > maxScore) {
        maxScore = score;
        bestDir = dir;
      }
    });

    const nx = this.x + bestDir.dx;
    const ny = this.y + bestDir.dy;
    
    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
      this.target.x = nx;
      this.target.y = ny;
      const key = `${this.x},${this.y},${opponent.x},${opponent.y},${this.hp}`;
      this.memory[key] = (this.memory[key] || 0) + Math.random() * 0.1;
    }
  }

  update() {
    const dx = (this.target.x - this.x) * MOVE_SPEED;
    const dy = (this.target.y - this.y) * MOVE_SPEED;
    this.x += dx;
    this.y += dy;
    
    if (Math.abs(this.x - this.target.x) < 0.1 &&
        Math.abs(this.y - this.target.y) < 0.1) {
      this.x = this.target.x;
      this.y = this.target.y;
    }
  }

  attack(opponent) {
    const damage = Math.floor(Math.random() * 20);
    opponent.hp = Math.max(0, opponent.hp - damage);
    this.hp = Math.max(0, this.hp - Math.random() * 10);
    
    if (damage > 0) {
      addEmoji(this.x, this.y, 'üí•');
      addEmoji(opponent.x, opponent.y, 'üí•');
      attackEffects.push({
        x: opponent.x * CELL_SIZE,
        y: opponent.y * CELL_SIZE,
        time: performance.now()
      });
    }
  }
}

function initGame() {
  canvas.width = GRID_SIZE * CELL_SIZE;
  canvas.height = GRID_SIZE * CELL_SIZE;
  grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(0));

  redAI = new AI(1, 0, 0, 0, 0);
  blueAI = new AI(2, GRID_SIZE-1, GRID_SIZE-1, GRID_SIZE-1, GRID_SIZE-1);

  grid[redAI.y][redAI.x] = 1;
  grid[blueAI.y][blueAI.x] = 2;
}

function update() {
  if (!gameRunning) return;

  redAI.decideMove(blueAI);
  blueAI.decideMove(redAI);

  redAI.update();
  blueAI.update();

  checkCollision(redAI, blueAI);
  checkCollision(blueAI, redAI);

  checkWinCondition();
}

function checkCollision(ai, opponent) {
  const dx = Math.abs(ai.x - opponent.x);
  const dy = Math.abs(ai.y - opponent.y);
  if (dx < 0.5 && dy < 0.5) {
    ai.attack(opponent);
  }
}

function checkWinCondition() {
  if (redAI.hp <= 0 || grid[redAI.baseY][redAI.baseX] === 2) {
    endGame('blue');
  } else if (blueAI.hp <= 0 || grid[blueAI.baseY][blueAI.baseX] === 1) {
    endGame('red');
  }
}

function endGame(winner) {
  gameRunning = false;
  saveMemory();

  const odds = winner === 'red' ? redOdds : blueOdds;
  const winAmount = Math.floor(betValue * odds);
  
  if (winner === betTeam) {
    playerBalance += winAmount;
    addLog(`–ü–æ–±–µ–¥–∞ ${winner}! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ ${winAmount} C`);
  } else {
    playerBalance -= betValue;
    addLog(`–ü–æ—Ä–∞–∂–µ–Ω–∏–µ! –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ ${betValue} C`);
  }

  resetBets();
  updateUI();
}

function addLog(message) {
  const entry = document.createElement('div');
  entry.textContent = message;
  logPanel.appendChild(entry);
  logPanel.scrollTop = logPanel.scrollHeight;
}

function saveMemory() {
  localStorage.setItem('redMemory', JSON.stringify(redMemory));
  localStorage.setItem('blueMemory', JSON.stringify(blueAI.memory));
}

function resetBets() {
  betTeam = null;
  betValue = 0;
  document.getElementById('betAmount').value = 100;
}

function updateUI() {
  document.getElementById('balance').textContent = playerBalance;
  document.getElementById('redOdds').textContent = (redOdds + Math.random() * 0.5).toFixed(2);
  document.getElementById('blueOdds').textContent = (blueOdds + Math.random() * 0.5).toFixed(2);
}

function betOn(team) {
  const amount = parseInt(document.getElementById('betAmount').value);
  if (amount > playerBalance) return alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤');
  
  betTeam = team;
  betValue = amount;
  playerBalance -= betValue;
  updateUI();
}

function startGame() {
  if (!betTeam) return alert('–°–¥–µ–ª–∞–π—Ç–µ —Å—Ç–∞–≤–∫—É!');
  
  initGame();
  gameRunning = true;
  requestAnimationFrame(animate);
  addLog('–ë–æ–π –Ω–∞—á–∞–ª—Å—è!');
}

function animate(time) {
  if (lastAnimationFrame && time - lastAnimationFrame < 16) return;
  lastAnimationFrame = time;
  
  update();
  render();
  if (gameRunning) requestAnimationFrame(animate);
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const cell = grid[y][x];
      ctx.fillStyle = cell === 1 ? '#e62e2e' : cell === 2 ? '#007bff' : '#333';
      ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
  }

  // –†–∏—Å—É–µ–º –ò–ò
  drawAI(redAI);
  drawAI(blueAI);

  // –≠—Ñ—Ñ–µ–∫—Ç—ã –∞—Ç–∞–∫–∏
  attackEffects = attackEffects.filter(e => performance.now() - e.time < 1000);
  attackEffects.forEach(e => {
    const size = 20 + (performance.now() - e.time) / 5;
    ctx.beginPath();
    ctx.arc(e.x + CELL_SIZE/2, e.y + CELL_SIZE/2, size, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fill();
  });

  // –≠–º–æ—Ü–∏–∏
  emojis = emojis.filter(e => performance.now() - e.time < 2000);
  emojis.forEach(e => {
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.fillText(e.symbol, 
      e.x * CELL_SIZE + CELL_SIZE/2, 
      e.y * CELL_SIZE + CELL_SIZE/2);
  });
}

function drawAI(ai) {
  const x = ai.x * CELL_SIZE;
  const y = ai.y * CELL_SIZE;

  ctx.fillStyle = ai.color;
  ctx.beginPath();
  ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2 - 4, 0, Math.PI*2);
  ctx.fill();

  // –†–∏—Å—É–µ–º HP
  ctx.fillStyle = '#222';
  ctx.fillRect(x, y - 15, CELL_SIZE, 10);
  ctx.fillStyle = ai.hp > 50 ? '#5cb85c' : '#d9534f';
  ctx.fillRect(x, y - 15, (ai.hp / MAX_HP) * CELL_SIZE, 10);
}

function addEmoji(x, y, symbol) {
  emojis.push({
    x: Math.floor(x),
    y: Math.floor(y),
    symbol,
    time: performance.now()
  });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
updateUI();
</script>
</body>
</html>
