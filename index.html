<!DOCTYPE html>
<html>
<head>
    <title>Neon Pulse</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            touch-action: manipulation;
        canvas {
            display: block;
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 400;

// 动态调整画布尺寸
function resize() {
    canvas.width = window.innerWidth * 0.95;
    canvas.height = window.innerHeight * 0.85;
window.addEventListener('resize', resize);
resize();

// 游戏状态
let gameState = 'menu';
let score = 0;
const particles = [];

// 玩家属性
const player = {
    x: 100,
    y: canvas.height/2,
    size: 30,
    velocityY: 0,
    color: '#00ff9d',
    jumpForce: -12,
    grounded: false
};

// 障碍系统
let obstacles = [];
let obstacleSpeed = 5;
let spawnRate = 120;
let frameCount = 0;

// 背景特效
let hue = 0;

function createParticles(x, y) {
    for (let i = 0; i < 5; i++) {
        particles.push({
            x: x,
            y: y,
            size: Math.random() * 3 + 2,
            speedX: (Math.random() - 0.5) * 3,
            speedY: (Math.random() - 0.5) * 3,
            color: `hsl(${hue}, 100%, 50%)`,
            alpha: 1
        });

function generateObstacle() {
    const height = Math.random() * 100 + 50;
    obstacles.push({
        x: canvas.width,
        y: canvas.height - height,
        width: 30,
        height: height,
        passed: false
    });

function drawMenu() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#00ff9d';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('NEON PULSE', canvas.width/2, canvas.height/2 - 40);
    
    ctx.fillStyle = '#fff';
    ctx.font = '20px Arial';
    ctx.fillText('Tap/Click to Start', canvas.width/2, canvas.height/2 + 20);

function gameLoop() {
    // 动态背景
    hue = (hue + 0.5) % 360;
    ctx.fillStyle = `hsl(${hue}, 60%, 5%)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 粒子特效
    particles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        p.x += p.speedX;
        p.y += p.speedY;
        p.alpha -= 0.02;
        
        if (p.alpha <= 0) particles.splice(i, 1);
    });
    ctx.globalAlpha = 1;

    if (gameState === 'playing') {
        // 生成障碍
        if (frameCount % spawnRate === 0) {
            generateObstacle();
            spawnRate = Math.max(60, spawnRate - 2);
            obstacleSpeed += 0.2;
        frameCount++;

        // 玩家物理
        player.velocityY += 0.5; // 重力
        player.y += player.velocityY;
        
        // 地面碰撞
        if (player.y + player.size > canvas.height) {
            player.y = canvas.height - player.size;
            player.velocityY = 0;
            player.grounded = true;
        } else {
            player.grounded = false;

        // 绘制玩家
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);

        // 障碍逻辑
        obstacles.forEach((obs, i) => {
            ctx.fillStyle = '#ff006e';
            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            
            obs.x -= obstacleSpeed;
            
            // 碰撞检测
            if (player.x < obs.x + obs.width &&
                player.x + player.size > obs.x &&
                player.y < obs.y + obs.height &&
                player.y + player.size > obs.y) {
                gameState = 'menu';
                score = 0;
                obstacles = [];
                obstacleSpeed = 5;
                spawnRate = 120;
            }
            
            // 计分
            if (!obs.passed && obs.x + obs.width < player.x) {
                score++;
                obs.passed = true;
            }
            
            if (obs.x + obs.width < 0) obstacles.splice(i, 1);
        });

        // 显示分数
        ctx.fillStyle = '#fff';
        ctx.font = '24px Arial';
        ctx.fillText(`Score: ${score}`, 20, 40);
    } else {
        drawMenu();

    requestAnimationFrame(gameLoop);

// 控制
canvas.addEventListener('click', () => {
    if (gameState === 'menu') {
        gameState = 'playing';
        player.y = canvas.height/2;
        player.velocityY = 0;
    } else if (player.grounded) {
        player.velocityY = player.jumpForce;
        createParticles(player.x + player.size/2, player.y + player.size);
});

// 触摸支持
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    canvas.click();
});

gameLoop();
</script>
</body>
</html>
